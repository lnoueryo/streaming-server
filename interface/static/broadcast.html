<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>WebRTC Broadcaster (JS ‚Üí Go SFU)</title>
  <style>
    body { background:#111;color:#eee;font-family:system-ui, sans-serif; padding:16px; }
    label { display:block; margin:8px 0 4px; }
    input { width:280px; padding:6px; }
    button { padding:8px 14px; margin-top:12px; }
    video { width: 480px; background:black; margin-top:16px; }
    pre { background:#222; padding:10px; max-height:180px; overflow:auto; }
    .row { display:flex; gap:24px; align-items:flex-start; flex-wrap:wrap; }
  </style>
</head>
<body>
  <h2>üì° Broadcaster (Browser as Publisher)</h2>

  <div class="row">
    <div>
      <label>WS URL</label>
      <input id="wsUrl" value="ws://localhost:8080/ws" />
      <label>Room ID</label>
      <input id="roomId" type="number" value="1" />
      <label>User IDÔºà‰ªªÊÑè„ÉªÈáçË§áÁ¶ÅÊ≠¢Êé®Â•®Ôºâ</label>
      <input id="userId" value="2" />
      <div style="margin-top:10px;">
        <button id="startBtn">Start Broadcast</button>
        <button id="stopBtn" disabled>Stop</button>
      </div>
      <details style="margin-top:10px;">
        <summary>„É≠„Ç∞</summary>
        <pre id="log"></pre>
      </details>
    </div>

    <div>
      <div>Local Preview</div>
      <video id="local" playsinline autoplay muted></video>
    </div>
  </div>

<script>
(function(){
  const $ = (id) => document.getElementById(id);
  const log = (m) => { const el = $("log"); el.textContent += m + "\n"; el.scrollTop = el.scrollHeight; console.log(m); };

  let ws = null;
  let pc = null;
  let localStream = null;

  $("startBtn").addEventListener("click", start);
  $("stopBtn").addEventListener("click", stop);

  async function start(){
    const WS_URL = $("wsUrl").value.trim();
    const roomId = parseInt($("roomId").value, 10);
    const userId = parseInt($("userId").value.trim(), 10) || undefined;

    // 1) WebSocket Êé•Á∂ö
    ws = new WebSocket(WS_URL);
    ws.onopen = () => {
      log("WS: connected");
      // 1-1) joinÔºàÊúÄÂàù„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Åß roomId/role/userId „ÇíÈÄÅ„ÇãÔºâ
      console.log(roomId)
      console.log(userId)
      ws.send(JSON.stringify({ type: "join", roomId, userId }));
    };
    ws.onclose = (e) => log(`WS: closed code=${e.code} reason=${e.reason || "(none)"}`);
    ws.onerror = (e) => log(`WS: error ${e.message || e}`);

    ws.onmessage = async (ev) => {
        const msg = safeParse(ev.data);
        console.log(msg)
      if(!msg) return;

      if (msg.type === "answer" && msg.sdp) {
        // 4) „Çµ„Éº„Éê„Éº„ÅÆ Answer „ÇíÈÅ©Áî®
        await pc.setRemoteDescription({ type:"answer", sdp: String(msg.sdp) });
        log("RTC: setRemoteDescription(answer) OK");
      } else if (msg.type === "candidate" && pc) {
        // 5) „Çµ„Éº„Éê„ÉºÁµåÁî±„ÅßÂ±ä„ÅÑ„Åü ICE candidate „ÇíÁôªÈå≤
        const c = {
          candidate: msg.candidate,
          sdpMid: msg.sdpMid ?? null,
          sdpMLineIndex: (typeof msg.sdpMLineIndex === "number") ? msg.sdpMLineIndex : null,
          usernameFragment: msg.usernameFragment ?? undefined,
        };
        try {
          await pc.addIceCandidate(c);
          log("RTC: addIceCandidate OK");
        } catch (err) {
          log("RTC: addIceCandidate ERR " + err);
        }
      } else {
        // „Åù„Çå‰ª•Â§ñ„ÅÆÈÄöÁü•ÔºàÂøÖË¶Å„Å™„ÇâÂá¶ÁêÜÔºâ
        log("WS msg: " + ev.data);
      }
    };

    // 2) „É°„Éá„Ç£„Ç¢ÂèñÂæó
    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: { width: {ideal:1280}, height: {ideal:720}, frameRate: {ideal:30} },
        audio: true
      });
      $("local").srcObject = localStream;
      log("Media: got local stream");
    } catch (e) {
      log("Media error: " + e.message);
      cleanup();
      return;
    }

    // 3) RTCPeerConnection ÊßãÁØâ
    pc = new RTCPeerConnection({
      // STUN „ÅØ„ÅÇ„Å™„Åü„ÅÆ„Çµ„Éº„Éê„Å®Âêà„Çè„Åõ„Å¶
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
    });

    // 3-1) „É≠„Éº„Ç´„É´„Éà„É©„ÉÉ„ÇØ„ÇíËøΩÂä†ÔºàÂÖà„Å´ addTrack ‚Üí createOfferÔºâ
    localStream.getTracks().forEach(t => {
      pc.addTrack(t, localStream);
    });

    // 3-2) ICE candidate „Çí„Çµ„Éº„Éê„Å∏‰∏≠Á∂ô
    pc.onicecandidate = (ev) => {
      if (ev.candidate && ws && ws.readyState === WebSocket.OPEN) {
        const c = ev.candidate.toJSON(); // {candidate, sdpMid, sdpMLineIndex, usernameFragment}
        ws.send(JSON.stringify({ type: "candidate", ...c }));
        // „Çµ„Éº„Éê„ÅØ webrtc.ICECandidateInit „Å´Ë©∞„ÇÅ„Å¶ AddICECandidate „Åô„ÇãÊÉ≥ÂÆö
        log("RTC: sent candidate");
      }
    };

    // 3-3) Êé•Á∂öÁä∂ÊÖã„É≠„Ç∞
    pc.oniceconnectionstatechange = () => log("ICE state: " + pc.iceConnectionState);
    pc.onsignalingstatechange = () => log("Signaling: " + pc.signalingState);

    // 3-4) Offer ÁîüÊàê„ÉªÈÄÅ‰ø°
    try {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer); // ufrag/pwd „ÅåÂÖ•„Çã
      log("RTC: setLocalDescription(offer) OK");
      wsSend({ type:"offer", sdp: pc.localDescription.sdp });
    } catch (e) {
      log("RTC offer error: " + e.message);
      cleanup();
      return;
    }

    $("startBtn").disabled = true;
    $("stopBtn").disabled = false;
  }

  async function stop(){
    log("Stop pressed");
    cleanup();
    $("startBtn").disabled = false;
    $("stopBtn").disabled = true;
  }

  function cleanup(){
    if (pc) {
      try { pc.getSenders().forEach(s => { try { s.replaceTrack(null); } catch(_){} }); } catch(_) {}
      try { pc.close(); } catch(_) {}
      pc = null;
    }
    if (localStream) {
      localStream.getTracks().forEach(t => { try { t.stop(); } catch(_){} });
      localStream = null;
      $("local").srcObject = null;
    }
    if (ws && ws.readyState === WebSocket.OPEN) {
      try { ws.close(1000, "normal"); } catch(_) {}
    }
    ws = null;
  }

  function wsSend(obj){
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(obj));
      log("WS ‚Üí " + JSON.stringify(obj).slice(0, 200));
    } else {
      log("WS not open; drop: " + JSON.stringify(obj));
    }
  }

  function safeParse(s){
    try { return JSON.parse(s); } catch(_) { log("WS parse error: " + s); return null; }
  }
})();
    console.log('broadcast')
</script>
</body>
</html>